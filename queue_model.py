# -*- coding: utf-8 -*-
"""011172175.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mq-KdNtPlzc5mB-Q6qNsTfaqosBzPiul
"""

import numpy as np
if (option==1):
  class SSQ:
    def __init__(self):   #Initialization
      #self.interarrivals= [0.4,1.2,0.5,1.7,0.2,1.6,0.2,1.4,1.9]  #exponential distribution 
      #self.service_times= [2.0,0.7,0.2,1.1,3.7,0.6,0.7,0.9,1.2]  #exponential distribution
      
      self.interarrivals= list(np.random.exponential(1.2,60))
      self.service_times= list(np.random.exponential(1.3, 60))
      
      self.clock= 0.0
      
      self.next_arrival=self.interarrivals.pop(0)
      self.next_departure1= float('inf')
      self.next_departure2=float('inf')
      
      self.num_in_queue= 0
      self.times_of_arrivalqueue= []         #store times of arrivals who are waiting in the queue
      self.service_times_in_queue= []   #store service times of waiting customers in the queue
      
      self.total_delay=0.0
      self.num_of_delays= 0.0
      self.area_under_q= 0.0
      self.area_under_b1= 0.0
      self.area_under_b2= 0.0
      
      self.server1_status= 0        #0 for IDLE , 1 for BUSY
      self.server2_status=0
      self.last_event_time=0.0     #we will need to store last event clock time 
  
    def start(self):
      while self.num_of_delays<6:
        self.timing()
      self.clock_step()
    
    def timing(self):
      self.clock= min(self.next_arrival,self.next_departure1,self.next_departure2)  #First set clock to minimum time of next event
      self.update_register()
      if self.next_arrival<= self.next_departure1 and self.next_arrival<=self.next_departure2:
        self.arrival()
        self.last_event_time=self.clock

        print("Arrival at Clock:" +str(self.clock))

      elif self.next_departure1<=self.next_arrival and self.next_departure1<=self.next_departure2:
        self.departure1()
        self.last_event_time=self.clock
        print("Departure at server1 at "+str(self.clock))
      
      else:
        self.departure2()
        self.last_event_time=self.clock
        print("Departure at server2 at "+str(self.clock))
      print("Server1 Status:"+str(self.server1_status))
      print("Server2 Status:"+str(self.server2_status))
      print("Times of arrivals in Queue: "+ str(self.times_of_arrivalqueue))
      print("Service times in Queue: "+str(self.service_times_in_queue))
      print("Total Delay:" +str(self.total_delay))
      print("Next Arrival Time: "+str(self.next_arrival))
      print("Next Departure of server1 Time: "+str(self.next_departure1))
      print("Next Departure of server2 Time: "+str(self.next_departure2))

      print(" ")

    def arrival(self):
      #Schedule next arrival , new_arrival = previous_arrival + inter_arrival time of next customer
      self.next_arrival= self.next_arrival+ self.interarrivals.pop(0)  
      
      if self.server1_status==0:   #server is idle
        self.server1_status= 1    #make server BUSY
        delay=0.0            #so delay is zero
        self.total_delay += delay  
        self.num_of_delays +=1   #increase the number of customers delayed

        #schedule next departure, pop the first element of service_times list to get service time of this customer
        self.next_departure1 = self.clock+ self.service_times.pop(0) 

      elif self.server2_status==0:   #server is idle
        self.server2_status= 1    #make server BUSY
        delay=0.0            #so delay is zero
        self.total_delay += delay  
        self.num_of_delays +=1   #increase the number of customers delayed

        #schedule next departure, pop the first element of service_times list to get service time of this customer
        self.next_departure2 = self.clock+ self.service_times.pop(0) 

      
    
      else:     #Server is BUSY
        #increase queue length, this customer will have to wait in the queue
        self.num_in_queue+=1

        #store the arrival time and service time of this customer in seperate lists
        self.times_of_arrivalqueue.append(self.clock) 
        self.service_times_in_queue.append(self.service_times.pop(0)) 

    def departure1(self): ##depart from server-1
      #check number of customers in the queue
      if self.num_in_queue==0:  #if no customer in the queue
        #make server IDLE 
        self.server1_status= 0
        #schedule next departure= infinity
        self.next_departure1= float('infinity')
      
      else: 
        #if queue not empty, pop one customer, decrease queue length
        self.num_in_queue-=1
        self.num_of_delays+=1
        #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
        #For SJF, finf the index of minimum service time from  service_times_in_queue list.
        #Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.  
      
        arrival= self.times_of_arrivalqueue.pop(0) 
        
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure1= self.clock+ self.service_times_in_queue.pop(0)

    def departure2(self):
      ##depart from server-1
      #check number of customers in the queue
      if self.num_in_queue==0:  #if no customer in the queue
        #make server IDLE 
        self.server2_status= 0
        #schedule next departure= infinity
        self.next_departure2= float('infinity')
      
      else: 
        #if queue not empty, pop one customer, decrease queue length
        self.num_in_queue-=1
        self.num_of_delays+=1
        #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
        #For SJF, finf the index of minimum service time from  service_times_in_queue list.
        #Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.  
      
        arrival= self.times_of_arrivalqueue.pop(0) 
        
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure2= self.clock+ self.service_times_in_queue.pop(0)



    def update_register(self):
      time_difference= self.clock - self.last_event_time
      self.area_under_q += time_difference*self.num_in_queue
      self.area_under_b1 +=  time_difference*self.server1_status
      self.area_under_b2 += time_difference*self.server2_status
      self.last_event_time=self.clock
      
      
    

    def clock_step(self): 
      avg_delay=self.total_delay/6
      exp_num_customer=self.area_under_q/self.last_event_time
      utilization1=self.area_under_b1/self.last_event_time
      utilization2=self.area_under_b2/self.last_event_time
      print("Average delay: ", avg_delay )
      print("Expected number of customer in the queue: ",exp_num_customer )
      print("Expected utilization of the server-1: ",utilization1 )
      print("Expected utilization of the server-2: ",utilization2 )

if option==2:
 class SSQ:
    def __init__(self):   #Initialization
      #self.interarrivals= [0.4,1.2,0.5,1.7,0.2,1.6,0.2,1.4,1.9]  #exponential distribution 
      #self.service_times= [2.0,0.7,0.2,1.1,3.7,0.6,0.7,0.9,1.2]  #exponential distribution
      
      self.interarrivals= list(np.random.exponential(1.2,60))
      self.service_times= list(np.random.exponential(1.3, 60))
      
      self.clock= 0.0
      
      self.next_arrival=self.interarrivals.pop(0)
      self.next_departure1= float('inf')
      self.next_departure2=float('inf')
      
      self.num_in_queue= 0
      self.times_of_arrivalqueue= []         #store times of arrivals who are waiting in the queue
      self.service_times_in_queue= []   #store service times of waiting customers in the queue
      
      self.total_delay=0.0
      self.num_of_delays= 0.0
      self.area_under_q= 0.0
      self.area_under_b1= 0.0
      self.area_under_b2= 0.0
      
      self.server1_status= 0        #0 for IDLE , 1 for BUSY
      self.server2_status=0
      self.last_event_time=0.0     #we will need to store last event clock time 
  
    def start(self):
      while self.num_of_delays<6:
        self.timing()
      self.clock_step()
    
    def timing(self):
      self.clock= min(self.next_arrival,self.next_departure1,self.next_departure2)  #First set clock to minimum time of next event
      self.update_register()
      if self.next_arrival<= self.next_departure1 and self.next_arrival<=self.next_departure2:
        self.arrival()
        self.last_event_time=self.clock

        print("Arrival at Clock:" +str(self.clock))

      elif self.next_departure1<=self.next_arrival and self.next_departure1<=self.next_departure2:
        self.departure1()
        self.last_event_time=self.clock
        print("Departure at server1 at "+str(self.clock))
      
      else:
        self.departure2()
        self.last_event_time=self.clock
        print("Departure at server2 at "+str(self.clock))
      print("Server1 Status:"+str(self.server1_status))
      print("Server2 Status:"+str(self.server2_status))
      print("Times of arrivals in Queue: "+ str(self.times_of_arrivalqueue))
      print("Service times in Queue: "+str(self.service_times_in_queue))
      print("Total Delay:" +str(self.total_delay))
      print("Next Arrival Time: "+str(self.next_arrival))
      print("Next Departure of server1 Time: "+str(self.next_departure1))
      print("Next Departure of server2 Time: "+str(self.next_departure2))

      print(" ")

    def arrival(self):
      #Schedule next arrival , new_arrival = previous_arrival + inter_arrival time of next customer
      self.next_arrival= self.next_arrival+ self.interarrivals.pop(0)  
      
      if self.server1_status==0:   #server is idle
        self.server1_status= 1    #make server BUSY
        delay=0.0            #so delay is zero
        self.total_delay += delay  
        self.num_of_delays +=1   #increase the number of customers delayed

        #schedule next departure, pop the first element of service_times list to get service time of this customer
        self.next_departure1 = self.clock+ self.service_times.pop(0) 

      elif self.server2_status==0:   #server is idle
        self.server2_status= 1    #make server BUSY
        delay=0.0            #so delay is zero
        self.total_delay += delay  
        self.num_of_delays +=1   #increase the number of customers delayed

        #schedule next departure, pop the first element of service_times list to get service time of this customer
        self.next_departure2 = self.clock+ self.service_times.pop(0) 

      
    
      else:     #Server is BUSY
        #increase queue length, this customer will have to wait in the queue
        self.num_in_queue+=1

        #store the arrival time and service time of this customer in seperate lists
        self.times_of_arrivalqueue.append(self.clock) 
        self.service_times_in_queue.append(self.service_times.pop(0)) 

    def departure1(self): ##depart from server-1
      #check number of customers in the queue
      if self.num_in_queue==0:  #if no customer in the queue
        #make server IDLE 
        self.server1_status= 0
        #schedule next departure= infinity
        self.next_departure1= float('infinity')
      
      else: 
        #if queue not empty, pop one customer, decrease queue length
        self.num_in_queue-=1
        self.num_of_delays+=1
        #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
        #For SJF, finf the index of minimum service time from  service_times_in_queue list.
        #Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.  
      
        arrival= self.times_of_arrivalqueue.pop(0) 
        
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure1= self.clock+ self.service_times_in_queue.pop(0)

    def departure2(self):
      ##depart from server-1
      #check number of customers in the queue
      if self.num_in_queue==0:  #if no customer in the queue
        #make server IDLE 
        self.server2_status= 0
        #schedule next departure= infinity
        self.next_departure2= float('infinity')
      
      else: 
        #if queue not empty, pop one customer, decrease queue length
        self.num_in_queue-=1
        self.num_of_delays+=1
        #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
        #For SJF, finf the index of minimum service time from  service_times_in_queue list.
        #Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.  
      
        arrival= self.times_of_arrivalqueue.pop(-1)
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure2= self.clock+ self.service_times_in_queue.pop(-1)



    def update_register(self):
      time_difference= self.clock - self.last_event_time
      self.area_under_q += time_difference*self.num_in_queue
      self.area_under_b1 +=  time_difference*self.server1_status
      self.area_under_b2 += time_difference*self.server2_status
      self.last_event_time=self.clock
      
      
    

    def clock_step(self): 
      avg_delay=self.total_delay/6
      exp_num_customer=self.area_under_q/self.last_event_time
      utilization1=self.area_under_b1/self.last_event_time
      utilization2=self.area_under_b2/self.last_event_time
      print("Average delay: ", avg_delay )
      print("Expected number of customer in the queue: ",exp_num_customer )
      print("Expected utilization of the server-1: ",utilization1 )
      print("Expected utilization of the server-2: ",utilization2 )


if option==3:
   class SSQ:
    def __init__(self):   #Initialization
      #self.interarrivals= [0.4,1.2,0.5,1.7,0.2,1.6,0.2,1.4,1.9]  #exponential distribution 
      #self.service_times= [2.0,0.7,0.2,1.1,3.7,0.6,0.7,0.9,1.2]  #exponential distribution
      
      self.interarrivals= list(np.random.exponential(1.2,60))
      self.service_times= list(np.random.exponential(1.3, 60))
      
      self.clock= 0.0
      
      self.next_arrival=self.interarrivals.pop(0)
      self.next_departure1= float('inf')
      self.next_departure2=float('inf')
      
      self.num_in_queue= 0
      self.times_of_arrivalqueue= []         #store times of arrivals who are waiting in the queue
      self.service_times_in_queue= []   #store service times of waiting customers in the queue
      
      self.total_delay=0.0
      self.num_of_delays= 0.0
      self.area_under_q= 0.0
      self.area_under_b1= 0.0
      self.area_under_b2= 0.0
      
      self.server1_status= 0        #0 for IDLE , 1 for BUSY
      self.server2_status=0
      self.last_event_time=0.0     #we will need to store last event clock time 
  
    def start(self):
      while self.num_of_delays<6:
        self.timing()
      self.clock_step()
    
    def timing(self):
      self.clock= min(self.next_arrival,self.next_departure1,self.next_departure2)  #First set clock to minimum time of next event
      self.update_register()
      if self.next_arrival<= self.next_departure1 and self.next_arrival<=self.next_departure2:
        self.arrival()
        self.last_event_time=self.clock

        print("Arrival at Clock:" +str(self.clock))

      elif self.next_departure1<=self.next_arrival and self.next_departure1<=self.next_departure2:
        self.departure1()
        self.last_event_time=self.clock
        print("Departure at server1 at "+str(self.clock))
      
      else:
        self.departure2()
        self.last_event_time=self.clock
        print("Departure at server2 at "+str(self.clock))
      print("Server1 Status:"+str(self.server1_status))
      print("Server2 Status:"+str(self.server2_status))
      print("Times of arrivals in Queue: "+ str(self.times_of_arrivalqueue))
      print("Service times in Queue: "+str(self.service_times_in_queue))
      print("Total Delay:" +str(self.total_delay))
      print("Next Arrival Time: "+str(self.next_arrival))
      print("Next Departure of server1 Time: "+str(self.next_departure1))
      print("Next Departure of server2 Time: "+str(self.next_departure2))

      print(" ")

    def arrival(self):
      #Schedule next arrival , new_arrival = previous_arrival + inter_arrival time of next customer
      self.next_arrival= self.next_arrival+ self.interarrivals.pop(0)  
      
      if self.server1_status==0:   #server is idle
        self.server1_status= 1    #make server BUSY
        delay=0.0            #so delay is zero
        self.total_delay += delay  
        self.num_of_delays +=1   #increase the number of customers delayed

        #schedule next departure, pop the first element of service_times list to get service time of this customer
        self.next_departure1 = self.clock+ self.service_times.pop(0) 

      elif self.server2_status==0:   #server is idle
        self.server2_status= 1    #make server BUSY
        delay=0.0            #so delay is zero
        self.total_delay += delay  
        self.num_of_delays +=1   #increase the number of customers delayed

        #schedule next departure, pop the first element of service_times list to get service time of this customer
        self.next_departure2 = self.clock+ self.service_times.pop(0) 

      
    
      else:     #Server is BUSY
        #increase queue length, this customer will have to wait in the queue
        self.num_in_queue+=1

        #store the arrival time and service time of this customer in seperate lists
        self.times_of_arrivalqueue.append(self.clock) 
        self.service_times_in_queue.append(self.service_times.pop(0)) 

    def departure1(self): ##depart from server-1
      #check number of customers in the queue
      if self.num_in_queue==0:  #if no customer in the queue
        #make server IDLE 
        self.server1_status= 0
        #schedule next departure= infinity
        self.next_departure1= float('infinity')
      
      else: 
        #if queue not empty, pop one customer, decrease queue length
        self.num_in_queue-=1
        self.num_of_delays+=1
        #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
        #For SJF, finf the index of minimum service time from  service_times_in_queue list.
        #Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.  
      
        arrival= self.times_of_arrivalqueue.pop(0) 
        
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure1= self.clock+ self.service_times_in_queue.pop(0)

    def departure2(self):
      ##depart from server-1
      #check number of customers in the queue
      if self.num_in_queue==0:  #if no customer in the queue
        #make server IDLE 
        self.server2_status= 0
        #schedule next departure= infinity
        self.next_departure2= float('infinity')
      
      else: 
        #if queue not empty, pop one customer, decrease queue length
        self.num_in_queue-=1
        self.num_of_delays+=1
        #AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
        #For SJF, finf the index of minimum service time from  service_times_in_queue list.
        #Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.  
      
        index_min=self.service_times_in_queue.index(min(self.service_times_in_queue))
        arrival= self.times_of_arrivalqueue.pop(index_min)
        delay= self.clock- arrival
        self.total_delay+=delay
        self.next_departure2= self.clock+ self.service_times_in_queue.pop(index_min) 



    def update_register(self):
      time_difference= self.clock - self.last_event_time
      self.area_under_q += time_difference*self.num_in_queue
      self.area_under_b1 +=  time_difference*self.server1_status
      self.area_under_b2 += time_difference*self.server2_status
      self.last_event_time=self.clock
      
      
    

    def clock_step(self): 
      avg_delay=self.total_delay/6
      exp_num_customer=self.area_under_q/self.last_event_time
      utilization1=self.area_under_b1/self.last_event_time
      utilization2=self.area_under_b2/self.last_event_time
      print("Average delay: ", avg_delay )
      print("Expected number of customer in the queue: ",exp_num_customer )
      print("Expected utilization of the server-1: ",utilization1 )
      print("Expected utilization of the server-2: ",utilization2 )
  

print('for fifo press 1 for lifo press 2 for sjf press 3')

option = int(input()) 

s = SSQ()
s.start()
